major project -> socially -> social media application

Scalable authentication

creating server first

npm init -y    -> creating node project

npm i express mongoose dotenv

creating login first in backend

creating aauthentication -> login , signup -> first step in social media application -> also helps in ecommerce

have to create authentication in both frontend and backend

nodemon -> installed globally

checking api run regularly on insomnia

make app by express js
then connect mongoDB atlas by dbConnect.js file
then import it in index.js file

we are following MVC architecture

creating models , controllers and routers

creating authRouter with the help of authControllers -> signup and login and using them in index.js as authRouter

now creating User model in models


*******************************
const {email,password} = req.body;
we cannot use the above line of req without middlewares we have to use middlewares in express and also its a recommended practice

npm i morgan -> basic middleware tells in console which api is hitted

take care of error status codes

*****
you have to pass or save password in such a way that it can be not visible -> it is unethical
we have to use hash passwords by hashing algorithms
npm i bcrypt -> library used for hashing password one way
const hashedPassword = bcrypt.hash(password , 10);
****


at login we again use encryption and matched with the save to check

we are using JWT
JWT -> json web token

app must be storing something specific to keep login a user during user using the webapp for login purpose
we use token -> a string -> created/generated by the backend -> when user login by email and password -> token is called access token 
this token can also be copied by an cyber attack
this access token is advantageous as it have an expiry time predefined 
JWT can be made only by server and it is safest

npm i jsonwebtoken -> library to install JWT

this token can be decoded at jwt.io

we can also verify signature by pasting that key which we passed in jwt.sign();
its token has 3-> parts -> header , payload , signature

we have to store this token -> and used in react app in each request

we created a postController -> then postRouter which shows all posts by get requests we have to check and validate it through token generated

we will pass token in middleware and check whether the user is logined or not if already login already then only show posts

in request -> there are three things -> body,params,header 
tokens are passed and get by headers we need to pass in auth in api testing

if we set expiry time 15 min then every 15 min user has to re login this is also a bad experience so for that we have to use another token known as refresh token
refresh token is used to refresh the access token

token are stored locally at client side as 
accesToken in local Storage
refreshToken in cookies -> to precent from cross-side-scripting attack
http-only cookies are not accessed by javaScipt
they are not generally store in DB

stateless system -> not storing access tokens on the backend


*********************#2**************************

to run -> use nodemon 

to save refresh token in cookie -> middleware -> cookie-parser is used
npm i cookie-parser

cookies are bits of information that can verify user by saving information from bcakend to fronetend .... these are set by backend only in this project

saving refresh token at cookies by jwt name and making it httpOnly so frontend can not access it
showing staus code and error message to frontend is better for error handling rather only status code





now creating frontend

npx create-react-app client

using scss in place of css

npm i sass

more specificity , heirarchy

npm i react-router-dom

now for making api calls from backend we are using axios as it supports intercept calls

npm i axios  -> to install axios in our client app
it is similar to fetch

first we make an axiosClient then use only this client for all requests
""
import axios from 'axios';

export const axiosClient = axios.create({
    baseURL: 'http://localhost:4000',
    withCredentials: true
})
""

CORS -> cross origin resource sharing
frontend and backend both are on different locations on internet 
these both are different ip address so accesing directly is not possible
backend must allow CORS to use for the api by frontend

middle dependency is of cors
that must be configured 

install in server

npm i cors

""
app.use(cors({
    Credentials:true,
    origin:'http://localhost:3000'
}));
""

allow from this origin only cors

we must have different servers for frontend and backend do not host on same ports can work but wrong approach

handle submit using axios 
""
async function handleSubmit(e){
        e.preventDefault();
        const result = await axiosClient.post('/auth/login', {
            email,
            password
        });

        console.log(result);
    }
""



now storing access token from backend into our local storage of frontend


*****
now adding interceptors 

on expiring we dont wanna show to users that accesToken is expired these must be handled silently -> these can be done by interceptors

interceptors -> request interceptor , response interceptors

on getting 401 status -> access token expired -> interceptor itself called refresh api 

in a project these interceptors are genreally only one time set up -> coded

in every api we must ensure passing accessToken in body



dont need to install dotenv in react
all enviornment variables in react start as 
REACT_APP_(name)

after change in .env must restart client

if user is signed up or logined then show only home page snd do not show login and signup but if its not logined then not show home page

using protected route to open home page only if user is logined
if accessToken is deleted then it redirects to login

we coupled user and post by both the schemas

we have to handle each and every test case at backend properly

many time simply post request is used

for logout feature , we need to delete both accesToken as well as refreshToken
accessToken is deleted from local storage by frontend only
refreshToken is deleted from cookie by backend

req se nikalo data or res me daalo

Github Copilot extension -> very useful

these more features can be added
user -> getMyPosts , deleteMyProfile , getUserPosts 

.populate is used in find specific information more
populate works upon reference

deleting likes by simple loops is difficult 
so we are checking likes first and then deleting non existing users

always use cors before using routers in backend
write cors code before routers 

flaticon -> for images

use css variables in index.css which you have to use multiple times in the project and keeping them as standard like border-colour etc

pexels -> for images

npm install react-icons --save  -> to install react icons


we are using 
react-top-loading-bar library for a loading bar
npm install --save react-top-loading-bar

we have to fetch data component by component

we will use redux to call api to globally store data and state managment

npm i @reduxjs/toolkit in client

npm i react-redux

also wrapp app in provider in index.js
also add store in provider

we have to add loader in app so that it can access whole app and loader works everywhere

role managing information can be stored in appConfigSlice

reducers are pure functions we cannot use async in them so to perform asynchronous operations we have to use Redux Thunk

handleLogoutClicked -> made in future

file reader -> it helps in setting image as well as sending in post request to the backend

we are installing cloudinary in server for images
npm i cloudinary
it is used for storing and uploading images and modify at run time by transformation

config cloudinary and put all values as environment variables in dot env

resolve image issue later

do css nesting properly

useParams hook used to get parameters

must store each and every slice information in store of redux

for suggestion we can implement machine learning

mapping in backend is very important for data flow and presenting

the api which declared in async thunk are already async so do not need to declare async functions again for them

using tim-ago library for timestamps
npm i time-ago

we have to handle all errors globally so that no need to use catch everywhere

now we are using another library in client
react-hot-toast
npm i react-hot-toast
its for showing toast messages and errors

you can only dispatch from component directly

we have to remove all the warnings of the terminal

in deployment we have to use hashRouter in place of browser
router

deployment steps:
<BrowserRouter> -> change to -> <HashRouter> hash works properly also internal implementation is same as BrowserRouter

to upload on github first******
with icon and logo of signup and login page

npx create-react-app itself make an environment variable NODE_ENV which is not found in evironment variables

uploading using git to github





